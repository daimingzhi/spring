## 惰性队列

​	从**RabbitMQ 3.6.0**之后，有了 **Lazy Queues** 的概念---一个会尽早的将队列中的内容移动到磁盘的队列，并且只有当消费者需要的时候，才会将它们加载到内存中

​	惰性队列设计的一个主要的目的就是去支持非常长的队列（上亿级）。队列可能会变的非常长因为各种各样的原因：

- 消费者离线/宕机/停机维护
- 大量的请求突然涌入，生产者正在超过消费者
- 消费速度低于正常情况

​	默认情况下，当消息发送到RabbitMQ时，会被存储在内存中，这样做的主要目的是为了消息能尽快的发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份

​	队列具备两种模式：default和lazy。默认的为default模式，在3.6.0之前的版本无需做任何变更。lazy模式即为惰性队列的模式，可以通过调用channel.queueDeclare方法的时候在参数中设置，也可以通过Policy的方式设置，如果一个队列同时使用这两种方式设置的话，那么Policy的方式具备更高的优先级。如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。

​	在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示例中演示了一个惰性队列的声明细节

```java
Map<String, Object> args = new HashMap<String, Object>();
args.put("x-queue-mode", "lazy");
channel.queueDeclare("myqueue", false, false, false, args);
```

对应的Policy设置方式为：

```
rabbitmqctl	
rabbitmqctl set_policy Lazy "^lazy-queue$" '{"queue-mode":"lazy"}' --apply-to queues
rabbitmqctl (Windows)	
rabbitmqctl set_policy Lazy "^lazy-queue$" "{""queue-mode"":""lazy""}" --apply-to queues
```

​	惰性队列会将接收到的消息直接存入文件系统中，而不管是持久化的或者是非持久化的，这样可以减少了内存的消耗，但是会增加I/O的使用，如果消息是持久化的，那么这样的I/O操作不可避免，惰性队列和持久化消息可谓是“最佳拍档”。注意如果惰性队列中存储的是非持久化的消息，内存的使用率会一直很稳定，但**是重启之后消息一样会丢失**

​	据官网测试数据显示，对于普通队列，如果要发送1千万条消息，需要耗费801秒，平均发送速度约为13000条/秒。如果使用惰性队列，那么发送同样多的消息时，耗时是421秒，平均发送速度约为24000条/秒。出现性能偏差的原因是普通队列会由于内存不足而不得不将消息换页至磁盘。如果有消费者消费时，惰性队列会耗费将近40MB的空间来发送消息，对于一个消费者的情况，平均的消费速度约为14000条/秒。

​	如果要将普通队列转变为惰性队列，那么我们需要忍受同样的性能损耗。当转变为惰性队列的时候，首先需要将缓存中的消息换页至磁盘中，然后才能接收新的消息。反之，当将一个惰性队列转变为普通队列的时候，和恢复一个队列执行同样的操作，会将磁盘中的消息批量的导入到内存中。

参考：

​	[官网链接](https://www.rabbitmq.com/lazy-queues.html)

​	<https://blog.csdn.net/u013256816/article/details/77987216>