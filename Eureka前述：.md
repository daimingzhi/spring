Spring Cloud 学习 之 Spring Cloud Eureka（一）

Spring Boot版本：2.1.4.RELEASE

Spring Cloud版本：Greenwich.SR1

### 前述：

​	服务治理可以说是微服务架构中最为核心和基础的模块，它主要用来**实现各个微服务实例的自动化注册**于发现。为什么我们在微服务架构中那么需要服务治理模块呢？微服务系统没有它会有什么不好的地方吗？

​	在最初构建微服务系统的时候可能服务并不多，我们可以通过做一些静态的配置来实现服务的调用。比如有两个服务A和B，其中服务A需要调用服务B来完成一个业务操作时，为了失效服务B的高可用，不论采用服务端负载均衡还是客户端负载均衡，都需要手工维护服务B的实例清单。但是随着业务的发展，系统的功能越来越复杂，相应的微服务应用也不断增加，我们的静态配置就会变得越来越难以维护。并且面对不断发展的业务，我们的集群规模，服务位置，服务的命名都可能发生变化。同时对这类静态内容的维护也必将消耗大量的人力。

​	为了解决**微服务架构中的服务实例维护的问题**，产生了大量的服务治理的框架跟产品。这些框架跟产品的实现都围绕着**服务注册与服务发现机制**来完成对**服务应用实例的自动化管理**。

##### 服务注册：

​	在服务治理框架中，通常都会构建一个注册中心，每个服务单元向注册中心登记自己提供的服务，将主机与**端口号，版本号，通信协议**等一些附加信息告知注册中心。注册中心按服务名分类组织服务清单。比如我们有两个提供服务A的进程分别允许与192.168.0.100:8080和192.168.0.101:8080位置上，另外还有三个提供服务B的进程分别运行于192.168.0.100:9000,192.168.0.101:9000,192.168.0.102:9000,这些进程均向注册中心注册自己的服务之后，注册中心就会维护类似下面的一个服务清单。另外，**服务注册中心还需要以心跳的方式去检查清单中的服务是否可用，若不可用需要从服务清单中剔除，达到排除故障服务的效果**。

| 服务名 | 位置                                                     |
| ------ | -------------------------------------------------------- |
| 服务A  | 192.168.0.100:8080，192.168.0.101:8080                   |
| 服务B  | 192.168.0.100:9000,192.168.0.101:9000,192.168.0.102:9000 |

##### 服务发现：

​	由于在服务治理的框架下运作，服务间的调用不再通过指定具体的实例地址来实现，而是通过向服务发起请求调用实现。所以，服务调用方在调用服务提供方接口的时候，并不知道具体的服务实例的位置。因此，调用方需向服务注册中心咨询服务，并获取所有服务的注册清单，以实现对具体服务实例的访问。比如，现有服务C希望调用服务A，服务C就需要向注册中心发起咨询服务请求，**服务注册中心就会将服务A的位置清单返回给服务C**，如按上例服务A的情况，服务C就获得了服务A的两个可用位置192.168.0.100:8080，192.168.0.101:8080。当服务C要发起调用的时候，便从该清单中以某种轮询的策略取出一个位置来进行服务调用，这就是后续我们会介绍的客户端负载均衡。这里我们只是列举了一种简单的服务治理逻辑，以方便理解服务治理框架的基本运行思路。实际的框架为了性能等因素，不会采用每次都向服务注册中心获取服务的方式，并且不同的应用场景在缓存和服务剔除等机制上也会有一些不同的实现策略。

##### Eureka:

​	Spring Cloud Eureka,使用了Netflix Eureka来实现服务注册与发现，它既包含了服务端组件也包含客户端组件，并且**服务端组件跟客户端组件都采用Java编写**，所以Eureka主要适用于通过Java实现的分布式系统，或是与JVM兼容语言构建系统。但是，由于Eurka服务端的服务治理机制提供了完备的RESTful API，所以它也支持将非Java语言构建的微服务应用纳入Eureka的服务治理体系中来。

​	Eureka服务端，我们也称之为服务注册中心。它同其他服务注册中心一样，**支持高可用配置。它依托于强一致性提供良好的服务实例可用性，可以应对多种不同的故障场景。如果Eureka以集群的模式部署，当集群中有分片故障时，那么Eureka就转入自我保护模式。它允许在分片故障期间继续提供服务的发现跟注册。**

​	Eureka客户端，**主要处理服务的注册跟发现**。客户端服务通过**注解和参数配置**的方式，嵌入在客户端应用程序的代码中，在应用程序运行时，**Eureka客户端向注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约**。同时，**它也能从服务端查询当前注册的服务信息并将他们缓存到本地并周期性地刷新服务状态**。


​	

